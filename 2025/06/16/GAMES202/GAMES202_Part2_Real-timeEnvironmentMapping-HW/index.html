<!DOCTYPE html>
<html lang="zh-CN">

<!-- Head tag -->
<!-- MathJax for LaTeX support -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']]
  },
  svg: {
    fontCache: 'global'
  }
};
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script>

<head>

    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

    <!--Description-->

    

    
        <meta name="description" content="实时环境光照的作业：homework2耗时：4天
Assignment2中有prt和homework2（使用我们之前环境的网页）

prt下有CmakeList，以及包含一个nori框架。这里有几个事项要注意：
1.课程使用的nori已经嵌入其中了，不需要自己去clone。
–我跟着教程傻傻clon"/>
    

    <!--Author-->
    
        <meta name="author" content="EauDouceFish"/>
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="GAMES202-实时环境光照-作业2"/>
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="实时环境光照的作业：homework2耗时：4天
Assignment2中有prt和homework2（使用我们之前环境的网页）

prt下有CmakeList，以及包含一个nori框架。这里有几个事项要注意：
1.课程使用的nori已经嵌入其中了，不需要自己去clone。
–我跟着教程傻傻clon"/>
    

    <!--Open Graph Site Name-->
        <meta property="og:site_name" content="淡水鱼的山间客栈"/>

    <!--Type page-->
    
        <meta property="og:type" content="article"/>
    

    <!--Page Cover-->
    
    
        <meta property="og:image" content="https://eaudoucefish.github.ioimg/home-bg.jpg"/>
    

        <meta name="twitter:card" content="summary_large_image"/>

    

    
        <meta name="twitter:image" content="https://eaudoucefish.github.ioimg/home-bg.jpg"/>
    

    <!-- Title -->
    
    <title>GAMES202-实时环境光照-作业2 - 淡水鱼的山间客栈</title>

    <!-- Bootstrap Core CSS -->
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet"/>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/style.css">


    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/>
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css"/>
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css"/>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet"/>

    <!-- Google Analytics -->
    


    <!-- favicon -->
    

<meta name="generator" content="Hexo 7.3.0"></head>


<body>

    <!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">EauDouceFish's Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/">
                            
                                Home
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives">
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags">
                            
                                Tags
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/categories">
                            
                                Categories
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header" style="background-image: url('/img/home-bg.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>GAMES202-实时环境光照-作业2</h1>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                        
                            2025-06-16
                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           
                <div class="col-lg-4 col-lg-offset-2 col-md-5 col-md-offset-1 post-tags">
                    
                        


<a href="/tags/GAMES202/">#GAMES202</a>


                    
                </div>
                <div class="col-lg-4 col-md-5 post-categories">
                    
                        

<a href="/categories/GAMES202/">GAMES202</a>

                    
                </div>
            

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <h1 id="实时环境光照的作业：homework2"><a href="#实时环境光照的作业：homework2" class="headerlink" title="实时环境光照的作业：homework2"></a>实时环境光照的作业：homework2</h1><p>耗时：4天</p>
<p>Assignment2中有prt和homework2（使用我们之前环境的网页）</p>
<p><img src="/img/GAMES202/GAMES202_Part2_Real-timeEnvironmentMapping-HW/GAMES202_Part2_Real-timeEnvironmentMapping-HW_001.png"></p>
<p>prt下有CmakeList，以及包含一个nori框架。这里有几个事项要注意：</p>
<p>1.课程使用的nori已经嵌入其中了，不需要自己去clone。</p>
<p>–我跟着教程傻傻clone了nori编译报错排查了半天，后面发现不对劲</p>
<p>2.在论坛上都讨论过，在prt文件夹112行添加下面一行代码以适配UTF-8</p>
<p>  target_compile_options(nori PUBLIC &#x2F;utf-8) # MSVC unicode support</p>
<p>注意不要漏掉或者添加空格，不然无法解析（例如下面这个PUBLIC后面没有空格的版本是错误的）</p>
<p><img src="/img/GAMES202/GAMES202_Part2_Real-timeEnvironmentMapping-HW/GAMES202_Part2_Real-timeEnvironmentMapping-HW_002.png"></p>
<p><img src="/img/GAMES202/GAMES202_Part2_Real-timeEnvironmentMapping-HW/GAMES202_Part2_Real-timeEnvironmentMapping-HW_003.png"></p>
<p><img src="/img/GAMES202/GAMES202_Part2_Real-timeEnvironmentMapping-HW/GAMES202_Part2_Real-timeEnvironmentMapping-HW_004.png"></p>
<p>3.make指令windows无法使用，替代方案是使用cmake –build .指令</p>
<p>4.之后可能遇到报错：<font style="color:rgb(102, 102, 102);">c2039: ‘binary_function’: is not a member of ‘std’</font></p>
<p><font style="color:#000000;">这个函数在C++11后就被弃用了，我不知道为什么使用C++17标准以及这个库依然能跑通</font></p>
<p><font style="color:#000000;">替代方案是重写这个函数：</font></p>
<p><font style="color:#000000;">struct NameCompare {</font></p>
<p><font style="color:#000000;">    bool operator ()(const char* x, const char* y) const {</font></p>
<p><font style="color:#000000;">        return strcmp(x, y) &lt; 0;</font></p>
<p><font style="color:#000000;">    }</font></p>
<p><font style="color:#000000;">};</font></p>
<p><font style="color:#000000;">然后找到nori.sln，进行build</font></p>
<p><font style="color:#000000;">可能会报错，不用管</font></p>
<p><font style="color:#000000;">进入Debug&#x2F;目录下有个nori.exe</font></p>
<p><font style="color:#000000;">指令输入 .\nori.exe ..&#x2F;..&#x2F;scenes&#x2F;prt.xml</font></p>
<p><font style="color:#000000;">就可以打开我们的prt，看到渲染结果了</font></p>
<p><strong>环境配置好，开始正式作业</strong></p>
<p><img src="/img/GAMES202/GAMES202_Part2_Real-timeEnvironmentMapping-HW/GAMES202_Part2_Real-timeEnvironmentMapping-HW_005.png"></p>
<p>首先先看一下作业框架：</p>
<p><img src="/img/GAMES202/GAMES202_Part2_Real-timeEnvironmentMapping-HW/GAMES202_Part2_Real-timeEnvironmentMapping-HW_006.png"></p>
<p>简单了解一下这些库的作用：（直接搜索都可以找到对应项目）</p>
<p><strong>1.Eigen 随处可见的矩阵数学库</strong></p>
<p>2.filesystem C++17标准库的一部分，处理文件</p>
<p>3.hypothesis 是GitHub上的一个开源库，用于基础测试</p>
<p>4.nanogui 用于上述图形界面的展示</p>
<p>5.openexr 提供EXR文件格式的规范和参考实现，EXR是电影行业的专业级图像存储格式。</p>
<p>EXR格式的目的是准确、高效地表示高动态范围的场景线性图像数据。</p>
<p><strong>6.pcg32 是一个随机数生成器</strong></p>
<p>7.plugin 里面有个支持io的py文件，不重要</p>
<p>8.pugixml 是xml格式的解析库，用来处理场景，相机，光源，渲染参数等</p>
<p><strong>9.spherical-harmonics  提供SH相关的数学计算，可用来进行光照计算、处理环境光照、全局光照模型等等</strong></p>
<p>10.tbb 利用多线程进行并行计算， 并行化一些计算密集型任务，比如说光线与物体相交测试、场景遍历</p>
<p>11.tinyformat 格式化字符输出，不重要</p>
<p>12.zlib 压缩&#x2F;解压 场景图像数据</p>
<p>OpenEXR广泛应用于对精度要求很高的主机应用软件中，如真实感渲染、纹理访问、图像合成、深度合成和DI。</p>
<p><strong>作业思路</strong></p>
<p>作业第一部分（预计算部分）有三个事情要做</p>
<p>1.预计算环境光照</p>
<p>2.预计算漫反射项（无阴影）</p>
<p>3.预计算漫反射项（有阴影）</p>
<p>（1）预计算环境光照</p>
<p><img src="/img/GAMES202/GAMES202_Part2_Real-timeEnvironmentMapping-HW/GAMES202_Part2_Real-timeEnvironmentMapping-HW_007.png"></p>
<p>我们目标是把环境光投影到球谐函数，做投影本质是做product integral（上面的公式）</p>
<p>而作业要求使用黎曼积分获得环境光照，这里可以转化为使用黎曼积分进行求和的计算</p>
<p>回到作业框架，该函数前面部分遍历并且存储了6张贴图每个像素点和采样方向。</p>
<p>之后编译时候计算SH数量并且初始化系数为0，我们要根据数量计算每个SH的系数。</p>
<p>这里的channel指的是RGBA的使用通道数，*channel可以跳过不需要的通道</p>
<p><img src="/img/GAMES202/GAMES202_Part2_Real-timeEnvironmentMapping-HW/GAMES202_Part2_Real-timeEnvironmentMapping-HW_008.png"></p>
<p>所以我们总共需要这几个参数，然后求和结果：</p>
<p>$ L_{env}(\omega_i), SH(\omega_i),\Delta \omega_i $</p>
<p>1.对于$ L_{env}(\omega_i) $就算框架中的Le，获得环境光贴图的对应像素颜色</p>
<p>2.<strong>对于</strong>$ SH(\omega_i) $<strong>，也就是每个SH基函数，我们就是要对SH每一项进行遍历。</strong></p>
<p><strong>然后获得就是要对对应立体角进行SH基函数的计算</strong></p>
<p><strong>3.对于</strong>$ \Delta \omega_i $<strong>，就是每个像素投影到单位球面的面积，作业指导中给出了计算方式</strong></p>
<p><img src="/img/GAMES202/GAMES202_Part2_Real-timeEnvironmentMapping-HW/GAMES202_Part2_Real-timeEnvironmentMapping-HW_009.png"></p>
<p>所以就可以计算$ \Delta \omega_i $</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> delta_omega_i = <span class="built_in">CalcArea</span>(x, y, width, height);</span><br></pre></td></tr></table></figure>

<p>进行这三步计算之后，把结果填入之前开辟的SHCoefficient数组即可。</p>
<p>（2）中要根据这个图写出循环</p>
<p><img src="/img/GAMES202/GAMES202_Part2_Real-timeEnvironmentMapping-HW/GAMES202_Part2_Real-timeEnvironmentMapping-HW_010.png"></p>
<p>注意遍历（2）时候变量不可使用i和j，i会冲突，用SH的l和m即可</p>
<p>但遍历后我一开始不知道如何<strong>对对应立体角进行SH基函数的计算</strong></p>
<p><strong>好在根据给的框架spherical_harmonics中给了</strong><a target="_blank" rel="noopener" href="https://www.yuque.com/eaudouce/oax1gw/kgdoyxmah53s7qnh"><strong>计算方法</strong></a></p>
<p>方法提供一个重载，<strong>传入第l阶和第m项SH，和观察角度</strong>，就能得到对应的SH基函数值</p>
<p>注：SH基函数不仅仅和l与m有关，根据SH基函数定义，其还和方向有关</p>
<p><img src="/img/GAMES202/GAMES202_Part2_Real-timeEnvironmentMapping-HW/GAMES202_Part2_Real-timeEnvironmentMapping-HW_011.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> delta_omega_i = <span class="built_in">CalcArea</span>(x, y, width, height);</span><br><span class="line"><span class="comment">// 对SH每一阶进行遍历,一共有SHNum个</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>; l&lt;SHOrder; l++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> m = -l; m &lt;= l; m++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 传入计算基函数项</span></span><br><span class="line">        <span class="type">double</span> sh_basis_omega_i = sh::<span class="built_in">EvalSH</span>(l, m, Eigen::<span class="built_in">Vector3d</span>(dir).<span class="built_in">normalized</span>());</span><br><span class="line">        <span class="comment">// 之后进行黎曼积分,先获取索引，然后对每个投影系数求和</span></span><br><span class="line">        <span class="type">int</span> curIndex = sh::<span class="built_in">GetIndex</span>(l, m);</span><br><span class="line">        SHCoeffiecents[curIndex] += Le * sh_basis_omega_i * delta_omega_i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在进行环境光计算之后，还需要漫反射项无阴影&#x2F;有阴影&#x2F;有阴影+光线弹射的预计算</p>
<p><strong>1.Diffuse Unshadowed</strong></p>
<p>在做这部分作业的时候遇到了一些推导上的疑惑，原公式渲染方程为</p>
<p>$ L(x, \omega_0) &#x3D; \int_S f_r(x, \omega_i, \omega_o)L_i(x, \omega_i)H(x, \omega_i)d\omega_i $</p>
<p>对于漫反射，shading结果和观察方向无关，作业给出简化公式：</p>
<p>$ L_{DU} &#x3D; \frac{\rho}{\pi}\int_SL_i(x,\omega_i)max(N_x\cdot\omega_i,0)d\omega_i $</p>
<p>一开始没看懂是怎么转化的，后面了解了一下：</p>
<p>方程其中的$ H $项在物理学中一般代表光的遮挡或者传输<br>由于是Unshadowed，不需要考虑遮挡，H项就直接加入计算（常数1）</p>
<p>对于BRDF项，采用Lambert光照模型，我们有：</p>
<p>$ f_r(x,\omega_i,\omega_o) &#x3D; \frac{\rho}{\pi}max(\mathbf{N}\cdot\omega_i, 0) $</p>
<p>将常数$ \frac{\rho}{\pi} $提取出来，就能得到最后的简化公式</p>
<p>对PBR的lambert模型为什么BRDF项要除以$ \pi $，大家都知道原因是能量守恒</p>
<p>但是至于具体的推导，这里有非常好的参考文章：</p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/29837458">https://zhuanlan.zhihu.com/p/29837458</a></p>
<p>接下来就涉及到课程中最主要的思想，prt理论：</p>
<p>将渲染方程看作Light和LightTransport两项，分别投影到SH上</p>
<p>在Diffuse Unshadowed这里只是LightTransport 不需要考虑View项了</p>
<p><img src="/img/GAMES202/GAMES202_Part2_Real-timeEnvironmentMapping-HW/GAMES202_Part2_Real-timeEnvironmentMapping-HW_012.png"></p>
<p>在prt下面部分，<strong>我们刚完成了使用Cubemap拟合出SH，现在要投影LightTransport项了</strong></p>
<p>并且我们发现，Light项的投影我们已经完成了（Cubemap拟合SH）</p>
<p><strong>值得一提的是，这里给的伪代码的H似乎容易混淆公式中H的含义</strong></p>
<p>$ L(x, \omega_0) &#x3D; \int_S f_r(x, \omega_i, \omega_o)L_i(x, \omega_i)H(x, \omega_i)d\omega_i $</p>
<p>–在原渲染方程中，H项代表的是是否可见，几何项在BRDF中</p>
<p>$ L_{DU} &#x3D; \frac{\rho}{\pi}\int_SL_i(x,\omega_i)max(N_x\cdot\omega_i,0)d\omega_i $</p>
<p>–在简化后公式中，此处H由于不考虑阴影，已经消失了，而伪代码中的H代表的是几何项（$ n \cdot i $）：</p>
<p><img src="/img/GAMES202/GAMES202_Part2_Real-timeEnvironmentMapping-HW/GAMES202_Part2_Real-timeEnvironmentMapping-HW_013.png"></p>
<p>现在再来看公式，我们要做的就如文档介绍的那样：</p>
<p>Diffuse Unshadowed只需要<strong>把几何项进行投影即可，因为几何项就是LightTransport</strong></p>
<p>弄清楚这一点后，我想要分析一下作业代码部分实现，以此匹配伪代码来完成作业：</p>
<p><img src="/img/GAMES202/GAMES202_Part2_Real-timeEnvironmentMapping-HW/GAMES202_Part2_Real-timeEnvironmentMapping-HW_014.png"></p>
<p>仔细分析框架提供的LightTransport的投影方式：</p>
<p><img src="/img/GAMES202/GAMES202_Part2_Real-timeEnvironmentMapping-HW/GAMES202_Part2_Real-timeEnvironmentMapping-HW_015.png"></p>
<p>先读入mesh，获取顶点数，之后创建一个$ SH系数总数 \cdot 顶点数 $大小的矩阵</p>
<p><a target="_blank" rel="noopener" href="https://www.yuque.com/eaudouce/oax1gw/ffhkk9gvmfg0onyn?inner=u0f245ea9">在实时环境光照笔记中，分析了LightTransport项的投影是通过TransportMatrix实现</a></p>
<p>想必这就是TransportMatrix，在代码中，一般采用列主序（Eigen通常列主序）：</p>
<p>宽为顶点的数量，高为LightCoefficient数，每个顶点都要传输</p>
<p><img src="/img/GAMES202/GAMES202_Part2_Real-timeEnvironmentMapping-HW/GAMES202_Part2_Real-timeEnvironmentMapping-HW_016.png"></p>
<p>对于DU伪代码的逻辑是：</p>
<p>（1）对预计算拟合的SH进行采样样本，随机发射观察方向，遍历所有样本</p>
<p><strong>（2）检查是否H&gt;0.0（观察方向上几何项可见）如果H&gt;0.0，就执行（3）</strong></p>
<p>（3）把对应点都用H作为投影函数投影到每一项的SH系数上，累加RGB的结果</p>
<p>（4）最后对于每一项的SH系数，都乘上(权重&#x2F; 采样数) ， 求出BRDF 的球谐投影的系数向量</p>
<p>在执行伪代码之后，把结果存入transport matrix</p>
<p>可以发现，在框架实现中，步骤1、3、4在ProjectFunction中实现了，</p>
<p>最后把结果存入transport matrix中已经在preprocess函数中给了</p>
<p>步骤1、3</p>
<p><img src="/img/GAMES202/GAMES202_Part2_Real-timeEnvironmentMapping-HW/GAMES202_Part2_Real-timeEnvironmentMapping-HW_017.png"></p>
<p>步骤4</p>
<p><img src="/img/GAMES202/GAMES202_Part2_Real-timeEnvironmentMapping-HW/GAMES202_Part2_Real-timeEnvironmentMapping-HW_018.png"></p>
<p>存入transport matrix</p>
<p><img src="/img/GAMES202/GAMES202_Part2_Real-timeEnvironmentMapping-HW/GAMES202_Part2_Real-timeEnvironmentMapping-HW_019.png"></p>
<p>所以在TODO中只需要简单判断H是否大于0（半球上表面）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (m_Type == Type::Unshadowed)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> here you need to calculate unshadowed transport term of a given direction</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 此处你需要计算给定方向下的unshadowed传输项球谐函数值</span></span><br><span class="line">    <span class="type">double</span> H = wi.<span class="built_in">normalized</span>().<span class="built_in">dot</span>(n.<span class="built_in">normalized</span>());</span><br><span class="line">    <span class="keyword">if</span>(H &gt; <span class="number">0.0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> H;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.Diffuse Shadowed</strong></p>
<p>有阴影就是加入了Visibility项，判断一下是否有遮挡</p>
<p>伪代码中使用pos发出射线是否有和其他东西相交来判断，所以我认为也要这么做</p>
<p><img src="/img/GAMES202/GAMES202_Part2_Real-timeEnvironmentMapping-HW/GAMES202_Part2_Real-timeEnvironmentMapping-HW_020.png"></p>
<p>刚好文档里面提供了方法：</p>
<p><img src="/img/GAMES202/GAMES202_Part2_Real-timeEnvironmentMapping-HW/GAMES202_Part2_Real-timeEnvironmentMapping-HW_021.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> here you need to calculate shadowed transport term of a given direction</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 此处你需要计算给定方向下的shadowed传输项球谐函数值</span></span><br><span class="line">    <span class="keyword">if</span>(H &gt; <span class="number">0.0</span> &amp;&amp; scene-&gt;<span class="built_in">rayIntersect</span>(<span class="built_in">Ray3f</span>(v, wi)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> H;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/GAMES202/GAMES202_Part2_Real-timeEnvironmentMapping-HW/GAMES202_Part2_Real-timeEnvironmentMapping-HW_022.png"></p>
<p><img src="/img/GAMES202/GAMES202_Part2_Real-timeEnvironmentMapping-HW/GAMES202_Part2_Real-timeEnvironmentMapping-HW_023.png"></p>
<p>发现两个问题：</p>
<p>1.法线可视化代码没删掉</p>
<p>2.似乎光照反了！</p>
<p>删掉法线可视化后，法线是这里除了问题，少了个!导致原本是判断没有遮挡才可见，变成了有遮挡才可见</p>
<p><img src="/img/GAMES202/GAMES202_Part2_Real-timeEnvironmentMapping-HW/GAMES202_Part2_Real-timeEnvironmentMapping-HW_024.png"></p>
<p><img src="/img/GAMES202/GAMES202_Part2_Real-timeEnvironmentMapping-HW/GAMES202_Part2_Real-timeEnvironmentMapping-HW_025.png"></p>
<p>成功得出了正确的渲染结果！（右图为作业预期效果）</p>
<p><img src="/img/GAMES202/GAMES202_Part2_Real-timeEnvironmentMapping-HW/GAMES202_Part2_Real-timeEnvironmentMapping-HW_026.png"><img src="/img/GAMES202/GAMES202_Part2_Real-timeEnvironmentMapping-HW/GAMES202_Part2_Real-timeEnvironmentMapping-HW_027.png"></p>
<p><img src="/img/GAMES202/GAMES202_Part2_Real-timeEnvironmentMapping-HW/GAMES202_Part2_Real-timeEnvironmentMapping-HW_028.png"><img src="/img/GAMES202/GAMES202_Part2_Real-timeEnvironmentMapping-HW/GAMES202_Part2_Real-timeEnvironmentMapping-HW_029.png"><img src="/img/GAMES202/GAMES202_Part2_Real-timeEnvironmentMapping-HW/GAMES202_Part2_Real-timeEnvironmentMapping-HW_030.png"></p>
<p><img src="/img/GAMES202/GAMES202_Part2_Real-timeEnvironmentMapping-HW/GAMES202_Part2_Real-timeEnvironmentMapping-HW_031.png"></p>
<p>有两个场景的图太亮了，开始以为是曝光度导致的。在网上搜索一番信息后了解到，公式要除以PI</p>
<p>在prt.cpp中，在LightTransport Matrix中在最后阶段 除以PI再看看结果</p>
<p><img src="/img/GAMES202/GAMES202_Part2_Real-timeEnvironmentMapping-HW/GAMES202_Part2_Real-timeEnvironmentMapping-HW_032.png"></p>
<p>在此处对于PRT的基础实现告一段落，进入作业第二部分：</p>
<p>先按作业要求解开engine.js的88-114行 然后模仿PhongMaterial创建自己的PRTMaterial</p>
<p>（这里PDF有误，应该是作业0创建的PhongMaterial）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PRTMaterial</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Material</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">color, specular, light, translate, scale, vertexShader, fragmentShader</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> lightMVP = light.<span class="title class_">CalcLightMVP</span>(translate, scale);</span><br><span class="line">        <span class="keyword">let</span> lightIntensity = light.<span class="property">mat</span>.<span class="title class_">GetIntensity</span>();</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">super</span>(&#123;</span><br><span class="line">            <span class="comment">// PRT</span></span><br><span class="line">            <span class="string">&#x27;uSampler&#x27;</span>: &#123; <span class="attr">type</span>: <span class="string">&#x27;texture&#x27;</span>, <span class="attr">value</span>: color &#125;,</span><br><span class="line">            <span class="string">&#x27;uKs&#x27;</span>: &#123; <span class="attr">type</span>: <span class="string">&#x27;3fv&#x27;</span>, <span class="attr">value</span>: specular &#125;,</span><br><span class="line">            <span class="string">&#x27;uLightRadiance&#x27;</span>: &#123; <span class="attr">type</span>: <span class="string">&#x27;3fv&#x27;</span>, <span class="attr">value</span>: lightIntensity &#125;,</span><br><span class="line">            <span class="comment">// Shadow</span></span><br><span class="line">            <span class="string">&#x27;uShadowMap&#x27;</span>: &#123; <span class="attr">type</span>: <span class="string">&#x27;texture&#x27;</span>, <span class="attr">value</span>: light.<span class="property">fbo</span> &#125;,</span><br><span class="line">            <span class="string">&#x27;uLightMVP&#x27;</span>: &#123; <span class="attr">type</span>: <span class="string">&#x27;matrix4fv&#x27;</span>, <span class="attr">value</span>: lightMVP &#125;,</span><br><span class="line"></span><br><span class="line">        &#125;, [], vertexShader, fragmentShader, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">buildPRTMaterial</span>(<span class="params">color, specular, light, translate, scale, vertexPath, fragmentPath</span>) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> vertexShader = <span class="keyword">await</span> <span class="title function_">getShaderString</span>(vertexPath);</span><br><span class="line">    <span class="keyword">let</span> fragmentShader = <span class="keyword">await</span> <span class="title function_">getShaderString</span>(fragmentPath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PRTMaterial</span>(color, specular, light, translate, scale, vertexShader, fragmentShader);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这个肯定还有一些需要改的</p>
<p>这些参数原先的用处：<strong>color用来给予MainTex，specular为Ks系数</strong></p>
<p><strong>light, translate, scale都是用来计算光照的</strong></p>
<p>由于我们完全是预计算信息，实现的是实时光照，所以并不需要像Phong材质中一样，有任何调整的参数</p>
<p>只需要预计算的Lighting和LightTransport</p>
<p>所以对于传输的参数先尽数删去</p>
<p><a target="_blank" rel="noopener" href="https://www.yuque.com/eaudouce/oax1gw/ovur7euiywu5adi4?inner=ufdd3ed68">这里研究了如何在框架中创造一个自己的材质</a></p>
<p>此外对于作业给的引导部分，讲述的不是很明白：</p>
<p><img src="/img/GAMES202/GAMES202_Part2_Real-timeEnvironmentMapping-HW/GAMES202_Part2_Real-timeEnvironmentMapping-HW_033.png"></p>
<p>一般在图形API对于自定义的type，我们要用类似 shaderProgram.setUniform(string, data)</p>
<p>的代码来绑定字符串uniform对应的数据，而在作业中已经存储在全局变量提供给我们了</p>
<p><img src="/img/GAMES202/GAMES202_Part2_Real-timeEnvironmentMapping-HW/GAMES202_Part2_Real-timeEnvironmentMapping-HW_034.png"></p>
<p><img src="/img/GAMES202/GAMES202_Part2_Real-timeEnvironmentMapping-HW/GAMES202_Part2_Real-timeEnvironmentMapping-HW_035.png"></p>
<p>根据prt的计算逻辑，先在顶点保存Light和LightTransform信息，之后计算光照，片元插值</p>
<p>所以先传递给顶点需要的uniform和attribute：</p>
<p><strong>由于预计算的Light（环境光）信息是不变的，所以传递使用uniform</strong></p>
<p><strong>LightTransport信息是跟随顶点改变的， 里面是每个顶点相关的光照数据，所以作为attribute存储传递</strong></p>
<hr>
<p>顶点部分计算光照，只要传入位置和法线以及预计算LT信息、光照信息</p>
<p>在片元要进行着色插值，传入法线，颜色，预计算LT</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">attribute</span> <span class="type">vec3</span> aVertexPosition;</span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec3</span> aNormalPosition;</span><br><span class="line"><span class="comment">// LightTransform矩阵保存在顶点</span></span><br><span class="line"><span class="keyword">attribute</span> <span class="type">mat3</span> aPrecomputeLT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量可以自动接收</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> uModelMatrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> uViewMatrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> uProjectionMatrix;</span><br><span class="line"><span class="comment">// 在材质中传递预计算的光照uniform</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat3</span> uPrecomputeL[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入片元着色器的参数</span></span><br><span class="line"><span class="keyword">varying</span> <span class="keyword">highp</span> <span class="type">mat3</span> vPrecomputeLT;</span><br><span class="line"><span class="keyword">varying</span> <span class="keyword">highp</span> <span class="type">vec3</span> vNormal;</span><br><span class="line"><span class="keyword">varying</span> <span class="keyword">highp</span> <span class="type">vec3</span> vColor;</span><br></pre></td></tr></table></figure>

<p>对应地，要在PRTMaterial中传递它</p>
<p>删除不必要的部分</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PRTMaterial</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Material</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">vertexShader, fragmentShader</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(&#123;</span><br><span class="line">            <span class="string">&#x27;uPrecomputeL[0]&#x27;</span>: &#123;<span class="attr">type</span>: <span class="string">&#x27;precomputeL&#x27;</span>, value : <span class="literal">null</span>&#125;,</span><br><span class="line">            <span class="string">&#x27;uPrecomputeL[1]&#x27;</span>: &#123;<span class="attr">type</span>: <span class="string">&#x27;precomputeL&#x27;</span>, value : <span class="literal">null</span>&#125;,</span><br><span class="line">            <span class="string">&#x27;uPrecomputeL[2]&#x27;</span>: &#123;<span class="attr">type</span>: <span class="string">&#x27;precomputeL&#x27;</span>, value : <span class="literal">null</span>&#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        [<span class="string">&#x27;aPrecomputeLT&#x27;</span>],</span><br><span class="line">        vertexShader, fragmentShader, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">buildPRTMaterial</span>(<span class="params">vertexPath, fragmentPath</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> vertexShader = <span class="keyword">await</span> <span class="title function_">getShaderString</span>(vertexPath);</span><br><span class="line">    <span class="keyword">let</span> fragmentShader = <span class="keyword">await</span> <span class="title function_">getShaderString</span>(fragmentPath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PRTMaterial</span>(vertexShader, fragmentShader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/img/GAMES202/GAMES202_Part2_Real-timeEnvironmentMapping-HW/GAMES202_Part2_Real-timeEnvironmentMapping-HW_036.png"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (objMaterial) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;PhongMaterial&#x27;</span>:</span><br><span class="line">        material = <span class="title function_">buildPhongMaterial</span>(colorMap, mat.<span class="property">specular</span>.<span class="title function_">toArray</span>(), light, <span class="title class_">Translation</span>, <span class="title class_">Scale</span>, <span class="string">&quot;./src/shaders/phongShader/phongVertex.glsl&quot;</span>, <span class="string">&quot;./src/shaders/phongShader/phongFragment.glsl&quot;</span>);</span><br><span class="line">        shadowMaterial = <span class="title function_">buildShadowMaterial</span>(light, <span class="title class_">Translation</span>, <span class="title class_">Scale</span>, <span class="string">&quot;./src/shaders/shadowShader/shadowVertex.glsl&quot;</span>, <span class="string">&quot;./src/shaders/shadowShader/shadowFragment.glsl&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Add your PRTmaterial here</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;SkyBoxMaterial&#x27;</span>:</span><br><span class="line">        material = <span class="title function_">buildSkyBoxMaterial</span>(<span class="string">&quot;./src/shaders/skyBoxShader/SkyBoxVertex.glsl&quot;</span>, <span class="string">&quot;./src/shaders/skyBoxShader/SkyBoxFragment.glsl&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;PRTMaterial&#x27;</span>:</span><br><span class="line">    material = <span class="title function_">buildPRTMaterial</span>(<span class="string">&quot;./src/shaders/prtShader/prtVertex.glsl&quot;</span>, <span class="string">&quot;./src/shaders/prtShader/prtFragment.glsl&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> load model - Add your Material here</span></span><br><span class="line">    <span class="comment">// loadOBJ(renderer, &#x27;assets/bunny/&#x27;, &#x27;bunny&#x27;, &#x27;addYourPRTMaterial&#x27;, boxTransform);</span></span><br><span class="line">    <span class="comment">// loadOBJ(renderer, &#x27;assets/bunny/&#x27;, &#x27;bunny&#x27;, &#x27;addYourPRTMaterial&#x27;, box2Transform);</span></span><br><span class="line">    <span class="keyword">let</span> maryTransform = <span class="title function_">setTransform</span>(<span class="number">0</span>, -<span class="number">35</span>, <span class="number">0</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="title function_">loadOBJ</span>(renderer, <span class="string">&#x27;assets/mary/&#x27;</span>, <span class="string">&#x27;mary&#x27;</span>, <span class="string">&#x27;PRTMaterial&#x27;</span>, maryTransform);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">createGUI</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> gui = <span class="keyword">new</span> dat.<span class="property">gui</span>.<span class="title function_">GUI</span>();</span><br><span class="line">        <span class="keyword">const</span> panelModel = gui.<span class="title function_">addFolder</span>(<span class="string">&#x27;Switch Environemtn Map&#x27;</span>);</span><br><span class="line">        panelModel.<span class="title function_">add</span>(guiParams, <span class="string">&#x27;envmapId&#x27;</span>, &#123; <span class="string">&#x27;GraceGathedral&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;Indoor&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;Skybox&#x27;</span>: <span class="number">2</span> &#125;).<span class="title function_">name</span>(<span class="string">&#x27;Envmap Name&#x27;</span>);</span><br><span class="line">        panelModel.<span class="title function_">open</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><img src="/img/GAMES202/GAMES202_Part2_Real-timeEnvironmentMapping-HW/GAMES202_Part2_Real-timeEnvironmentMapping-HW_037.png"></p>
<p>太亮了</p>
<p><img src="/img/GAMES202/GAMES202_Part2_Real-timeEnvironmentMapping-HW/GAMES202_Part2_Real-timeEnvironmentMapping-HW_038.png"></p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifdef GL_ES</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">varying</span> <span class="keyword">highp</span> <span class="type">vec3</span> vColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// toneMapping : toSRGB</span></span><br><span class="line"><span class="type">vec3</span> toneMapping(<span class="type">vec3</span> color) &#123;</span><br><span class="line">    <span class="type">vec3</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="type">float</span> value = color[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (value &lt;= <span class="number">0.0031308</span>)</span><br><span class="line">            result[i] = <span class="number">12.92</span> * value;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            result[i] = (<span class="number">1.0</span> + <span class="number">0.055</span>) * <span class="built_in">pow</span>(value, <span class="number">1.0</span> / <span class="number">2.4</span>) - <span class="number">0.055</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">    <span class="type">vec3</span> finalColor = toneMapping(vColor);</span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(finalColor, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得一提的是，第一个场景中，使用未除以$ \pi $的结果来说更好看，更明亮，就留它作为最后结果了</p>
<p>另外，第三张图的两个天空盒素材在作业两个区域中使用的不一样，需要将html的天空盒贴图改一下才是对的</p>
<p><strong>最终结果如下：</strong></p>
<p><img src="/img/GAMES202/GAMES202_Part2_Real-timeEnvironmentMapping-HW/GAMES202_Part2_Real-timeEnvironmentMapping-HW_039.png"></p>
<p><img src="/img/GAMES202/GAMES202_Part2_Real-timeEnvironmentMapping-HW/GAMES202_Part2_Real-timeEnvironmentMapping-HW_040.png"><img src="/img/GAMES202/GAMES202_Part2_Real-timeEnvironmentMapping-HW/GAMES202_Part2_Real-timeEnvironmentMapping-HW_041.png"></p>
<p><img src="/img/GAMES202/GAMES202_Part2_Real-timeEnvironmentMapping-HW/GAMES202_Part2_Real-timeEnvironmentMapping-HW_042.png"></p>
<p>可以看到PRT的效果确实好看啊！</p>
<h1 id="附：作业2框架SH库源码分析"><a href="#附：作业2框架SH库源码分析" class="headerlink" title="附：作业2框架SH库源码分析"></a>附：作业2框架SH库源码分析</h1><p>通过分析spherical_harmonics.h文件我们就可以得到这个库为我们提供的可用方法</p>
<ol>
<li>SphericalFunction</li>
</ol>
<p>接收一个$ \phi $一个$ \theta $，创建一个球面函数</p>
<p>2.GetCoefficientCount</p>
<p>获得用当前阶数SH模拟下的函数，其SH基函数的所有数量总和（order+1）^2</p>
<p>3.GetIndex</p>
<p>将l和m参数值进行转化为1维度数组索引</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">GetIndex</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> l * (l + <span class="number">1</span>) + m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.Eigen::Vector3d ToVector(double phi, double theta)</p>
<p>将传入一个$ \phi $一个$ \theta $，转化为3D坐标表示的角度</p>
<p>5.void ToSphericalCoords(const Eigen::Vector3d&amp; dir, double* phi, double* theta);</p>
<p>4的反向操作，写入传入的phi和theta中</p>
<p>6.ImageXToPhi与ImageYToTheta </p>
<p>将传入的像素坐标x和y在给定宽与高下转化为$ \phi $和$ \theta $</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">ImageXToPhi</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> width)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">ImageYToTheta</span><span class="params">(<span class="type">int</span> y, <span class="type">int</span> height)</span></span>;</span><br></pre></td></tr></table></figure>

<p>7.ToImageCoords </p>
<p>将球面坐标映射回图像像素坐标</p>
<p>8.EvalSH </p>
<p>计算并且返回给定l和m以及$ \phi $和$ \theta $下，SH基函数的值，接收两种传入参数方式</p>
<p>–适用低阶SH，在库中硬编码实现</p>
<p>9.EvalSHSlow</p>
<p>对于高阶SH精细化的计算。在库中使用递归实现</p>
<p>10.ProjectFunction</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;std::vector&lt;<span class="type">double</span>&gt;&gt; <span class="built_in">ProjectFunction</span>(</span><br><span class="line">    <span class="type">int</span> order, <span class="type">const</span> SphericalFunction&amp; func, <span class="type">int</span> sample_count);</span><br></pre></td></tr></table></figure>

<p>使用蒙特卡洛采样，将给定的球面函数用前order阶的SH拟合，将拟合后的基函数系数存储在vector中返回</p>
<p>这些系数可以使用GetIndex解开</p>
<p>11.ProjectEnvironment</p>
<p>给一张环境贴图Image，将其用SH拟合，同样返回SH基函数系数，包含RGB三个通道分别存储</p>
<p><strong>注意：</strong></p>
<p>ProjectFunction 处理的函数是一个标量函数</p>
<p>球面函数可以是任何基于方向的函数，而不仅仅是颜色。例如：</p>
<p>环境光强度，辐射度分布，漫反射反射率等</p>
<p>对于颜色，需要RGB三个通道来分别存储拟合，一套SH只能拟合一个量</p>
<p>12.EvalSHSum</p>
<p>解释：对于SH拟合后，CoEfficients代表了使用前n阶的所有l和m拟合后的SH结果</p>
<p><strong>也就是数据在所有的这些基函数上的投影结果。</strong></p>
<p>**通过拟合一个球面函数，得到的就是这些基函数的加权系数。  **</p>
<p>所以</p>
<p>通过给定一个Coeffs和一个方向，<strong>就能直接还原出那个方向的</strong>**<font style="color:#DF2A3F;">球面函数</font>**<strong>的值</strong></p>
<p>这个函数就是用拟合后的SH的系数来还原出原球面函数的值的 </p>
<p>–同样有两个版本，支持方位角和向量表示</p>
<p>13.RenderDiffuseIrradianceMap</p>
<p>使用<strong>给定的环境贴图或者SH系数</strong>来渲染漫反射辐照度的图</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderDiffuseIrradianceMap</span><span class="params">(<span class="type">const</span> Image&amp; env_map, </span></span></span><br><span class="line"><span class="params"><span class="function">                                Image* diffuse_out)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderDiffuseIrradianceMap</span><span class="params">(<span class="type">const</span> std::vector&lt;Eigen::Array3f&gt;&amp; sh_coeffs,</span></span></span><br><span class="line"><span class="params"><span class="function">                                Image* diffuse_out)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>14.RenderDiffuseIrradiance</p>
<p>使用给定的SH系数和normal，计算normal的辐照度</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Eigen::Array3f <span class="title">RenderDiffuseIrradiance</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::vector&lt;Eigen::Array3f&gt;&amp; sh_coeffs, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> Eigen::Vector3d&amp; normal)</span></span>;</span><br></pre></td></tr></table></figure>



<p>15.一个Rotation类</p>
<p>提供几个方法用于对SH函数进行旋转</p>
<ul>
<li><code>**Create**</code> 方法：</li>
<li><code>Create(int order, const Eigen::Quaterniond&amp; rotation)</code>：创建一个 <code>Rotation</code> 对象，表示一个旋转，使用给定的 <code>order</code>（球面谐波阶数）和旋转四元数。旋转四元数定义了旋转的方向和角度。</li>
<li><code>Create(int order, const Rotation&amp; rotation)</code>：这个方法创建一个新的旋转，应用于相同阶数的球面谐波系数，目的是在相同旋转的基础上创建一个新的旋转变换，通常用于效率优化。</li>
<li><code>**Apply**</code> 方法：</li>
<li><code>Apply(const std::vector&lt;T&gt;&amp; coeffs, std::vector&lt;T&gt;* result)</code>：将旋转应用于传入的球面谐波系数 <code>coeffs</code>，并将结果存储在 <code>result</code> 向量中。这会返回一个新的旋转后的系数集，这些系数代表原始球面函数经过旋转后的效果。</li>
<li><code>**order**</code> 和 <code>**rotation**</code> 方法：</li>
<li><code>order()</code>：返回创建该旋转时指定的球面谐波阶数。</li>
<li><code>rotation()</code>：返回用于旋转的四元数。</li>
<li><code>**band_rotation**</code> 方法：</li>
<li><code>band_rotation(int l)</code>：给定一个阶数 <code>l</code>，返回一个旋转矩阵，用来变换球面谐波系数中 <code>l</code> 级别的系数。该矩阵大小为 <code>(2l+1) x (2l+1)</code>，是用于在特定阶数下执行旋转的矩阵。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright 2015 Google Inc. All Rights Reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment">// you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment">// You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment">// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment">// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment">// See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment">// limitations under the License.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The general spherical harmonic functions and fitting methods are from:</span></span><br><span class="line"><span class="comment">// 1. R. Green, &quot;Spherical Harmonic Lighting: The Gritty Details&quot;, GDC 2003,</span></span><br><span class="line"><span class="comment">//    http://www.research.scea.com/gdc2003/spherical-harmonic-lighting.pdf</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The environment map related functions are based on the methods in:</span></span><br><span class="line"><span class="comment">// 2. R. Ramamoorthi and P. Hanrahan, &quot;An Efficient Representation for</span></span><br><span class="line"><span class="comment">//    Irradiance Environment Maps&quot;,. , P., SIGGRAPH 2001, 497-500</span></span><br><span class="line"><span class="comment">// 3. R. Ramamoorthi and P. Hanrahan, “On the Relationship between Radiance and</span></span><br><span class="line"><span class="comment">//    Irradiance: Determining the Illumination from Images of a Convex</span></span><br><span class="line"><span class="comment">//    Lambertian Object,” J. Optical Soc. Am. A, vol. 18, no. 10, pp. 2448-2459,</span></span><br><span class="line"><span class="comment">//    2001.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Spherical harmonic rotations are implemented using the recurrence relations</span></span><br><span class="line"><span class="comment">// described by:</span></span><br><span class="line"><span class="comment">// 4. J. Ivanic and K. Ruedenberg, &quot;Rotation Matrices for Real Spherical</span></span><br><span class="line"><span class="comment">//    Harmonics. Direct Determination by Recursion&quot;, J. Phys. Chem., vol. 100,</span></span><br><span class="line"><span class="comment">//    no. 15, pp. 6342-6347, 1996.</span></span><br><span class="line"><span class="comment">//    http://pubs.acs.org/doi/pdf/10.1021/jp953350u</span></span><br><span class="line"><span class="comment">// 4b. Corrections to initial publication:</span></span><br><span class="line"><span class="comment">//    http://pubs.acs.org/doi/pdf/10.1021/jp9833350</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SH_SPHERICAL_HARMONICS_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SH_SPHERICAL_HARMONICS_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sh/image.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> M_PI</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M_PI 3.141592653589793f</span></span><br><span class="line"><span class="keyword">namespace</span> sh &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A spherical function, the first argument is phi, the second is theta.</span></span><br><span class="line"><span class="comment">// See EvalSH(int, int, double, double) for a description of these terms.</span></span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">double</span>(<span class="type">double</span>, <span class="type">double</span>)&gt; SphericalFunction;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kDefaultSampleCount = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the total number of coefficients for a function represented by</span></span><br><span class="line"><span class="comment">// all spherical harmonic basis of degree &lt;= @order (it is a point of</span></span><br><span class="line"><span class="comment">// confusion that the order of an SH refers to its degree and not the order).</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">GetCoefficientCount</span><span class="params">(<span class="type">int</span> order)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (order + <span class="number">1</span>) * (order + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the one dimensional index associated with a particular degree @l</span></span><br><span class="line"><span class="comment">// and order @m. This is the index that can be used to access the Coeffs</span></span><br><span class="line"><span class="comment">// returned by SHSolver.</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">GetIndex</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> l * (l + <span class="number">1</span>) + m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convert from spherical coordinates to a direction vector. @phi represents</span></span><br><span class="line"><span class="comment">// the rotation about the Z axis and is from [0, 2pi]. @theta represents the</span></span><br><span class="line"><span class="comment">// angle down from the Z axis, from [0, pi].</span></span><br><span class="line"><span class="function">Eigen::Vector3d <span class="title">ToVector</span><span class="params">(<span class="type">double</span> phi, <span class="type">double</span> theta)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convert from a direction vector to its spherical coordinates. The</span></span><br><span class="line"><span class="comment">// coordinates are written out to @phi and @theta. This is the inverse of</span></span><br><span class="line"><span class="comment">// ToVector.</span></span><br><span class="line"><span class="comment">// Check will fail if @dir is not unit.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ToSphericalCoords</span><span class="params">(<span class="type">const</span> Eigen::Vector3d&amp; dir, <span class="type">double</span>* phi, <span class="type">double</span>* theta)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convert the (x, y) pixel coordinates into spherical coordinates (phi, theta)</span></span><br><span class="line"><span class="comment">// suitable for use with spherical harmonic evaluation. The x image axis maps</span></span><br><span class="line"><span class="comment">// to phi (0 to 2pi) and the y image axis maps to theta (0 to pi). A pixel index</span></span><br><span class="line"><span class="comment">// maps to the center of the pixel, so phi = 2pi (x + 0.5) / width and</span></span><br><span class="line"><span class="comment">// theta = pi (y + 0.5) / height. This is consistent with ProjectEnvironmentMap.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// x and y are not bounds checked against the image, but given the repeated</span></span><br><span class="line"><span class="comment">// nature of trigonometry functions, out-of-bounds x/y values produce reasonable</span></span><br><span class="line"><span class="comment">// phi and theta values (e.g. extending linearly beyond 0, pi, or 2pi).</span></span><br><span class="line"><span class="comment">// Results are undefined if the image dimensions are less than or equal to 0.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The x and y functions are separated because they can be computed</span></span><br><span class="line"><span class="comment">// independently, unlike ToImageCoords.</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">ImageXToPhi</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> width)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">ImageYToTheta</span><span class="params">(<span class="type">int</span> y, <span class="type">int</span> height)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convert the (phi, theta) spherical coordinates (using the convention</span></span><br><span class="line"><span class="comment">// defined spherical_harmonics.h) to pixel coordinates (x, y). The pixel</span></span><br><span class="line"><span class="comment">// coordinates are floating point to allow for later subsampling within the</span></span><br><span class="line"><span class="comment">// image. This is the inverse of ImageCoordsToSphericalCoords. It properly</span></span><br><span class="line"><span class="comment">// supports angles outside of the standard (0, 2pi) or (0, pi) range by mapping</span></span><br><span class="line"><span class="comment">// them back into it.</span></span><br><span class="line"><span class="function">Eigen::Vector2d <span class="title">ToImageCoords</span><span class="params">(<span class="type">double</span> phi, <span class="type">double</span> theta, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Evaluate the spherical harmonic basis function of degree @l and order @m</span></span><br><span class="line"><span class="comment">// for the given spherical coordinates, @phi and @theta.</span></span><br><span class="line"><span class="comment">// For low values of @l this will use a hard-coded function, otherwise it</span></span><br><span class="line"><span class="comment">// will fallback to EvalSHSlow that uses a recurrence relation to support all l.</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">EvalSH</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> m, <span class="type">double</span> phi, <span class="type">double</span> theta)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Evaluate the spherical harmonic basis function of degree @l and order @m</span></span><br><span class="line"><span class="comment">// for the given direction vector, @dir.</span></span><br><span class="line"><span class="comment">// Check will fail if @dir is not unit.</span></span><br><span class="line"><span class="comment">// For low values of @l this will use a hard-coded function, otherwise it</span></span><br><span class="line"><span class="comment">// will fallback to EvalSHSlow that uses a recurrence relation to support all l.</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">EvalSH</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> m, <span class="type">const</span> Eigen::Vector3d&amp; dir)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// As EvalSH, but always uses the recurrence relationship. This is exposed</span></span><br><span class="line"><span class="comment">// primarily for testing purposes to ensure the hard-coded functions equal the</span></span><br><span class="line"><span class="comment">// recurrence relation version.</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">EvalSHSlow</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> m, <span class="type">double</span> phi, <span class="type">double</span> theta)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// As EvalSH, but always uses the recurrence relationship. This is exposed</span></span><br><span class="line"><span class="comment">// primarily for testing purposes to ensure the hard-coded functions equal the</span></span><br><span class="line"><span class="comment">// recurrence relation version.</span></span><br><span class="line"><span class="comment">// Check will fail if @dir is not unit.</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">EvalSHSlow</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> m, <span class="type">const</span> Eigen::Vector3d&amp; dir)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fit the given analytical spherical function to the SH basis functions</span></span><br><span class="line"><span class="comment">// up to @order. This uses Monte Carlo sampling to estimate the underlying</span></span><br><span class="line"><span class="comment">// integral. @sample_count determines the number of function evaluations</span></span><br><span class="line"><span class="comment">// performed. @sample_count is rounded to the greatest perfect square that</span></span><br><span class="line"><span class="comment">// is less than or equal to it.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The samples are distributed uniformly over the surface of a sphere. The</span></span><br><span class="line"><span class="comment">// number of samples required to get a reasonable sampling of @func depends on</span></span><br><span class="line"><span class="comment">// the frequencies within that function. Lower frequency will not require as</span></span><br><span class="line"><span class="comment">// many samples. The recommended default kDefaultSampleCount should be</span></span><br><span class="line"><span class="comment">// sufficiently high for most functions, but is also likely overly conservative</span></span><br><span class="line"><span class="comment">// for many applications.</span></span><br><span class="line">std::unique_ptr&lt;std::vector&lt;<span class="type">double</span>&gt;&gt; <span class="built_in">ProjectFunction</span>(</span><br><span class="line">    <span class="type">int</span> order, <span class="type">const</span> SphericalFunction&amp; func, <span class="type">int</span> sample_count);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fit the given environment map to the SH basis functions up to @order.</span></span><br><span class="line"><span class="comment">// It is assumed that the environment map is parameterized by theta along</span></span><br><span class="line"><span class="comment">// the x-axis (ranging from 0 to 2pi after normalizing out the resolution),</span></span><br><span class="line"><span class="comment">// and phi along the y-axis (ranging from 0 to pi after normalization).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This fits three different functions, one for each color channel. The</span></span><br><span class="line"><span class="comment">// coefficients for these functions are stored in the respective indices</span></span><br><span class="line"><span class="comment">// of the Array3f values of the returned vector.</span></span><br><span class="line">std::unique_ptr&lt;std::vector&lt;Eigen::Array3f&gt;&gt; <span class="built_in">ProjectEnvironment</span>(</span><br><span class="line">    <span class="type">int</span> order, <span class="type">const</span> Image&amp; env);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fit the given samples of a spherical function to the SH basis functions</span></span><br><span class="line"><span class="comment">// up to @order. This variant is used when there are relatively sparse</span></span><br><span class="line"><span class="comment">// evaluations or samples of the spherical function that must be fit and a</span></span><br><span class="line"><span class="comment">// regression is performed.</span></span><br><span class="line"><span class="comment">// @dirs and @values must have the same size. The directions in @dirs are</span></span><br><span class="line"><span class="comment">// assumed to be unit.</span></span><br><span class="line">std::unique_ptr&lt;std::vector&lt;<span class="type">double</span>&gt;&gt; <span class="built_in">ProjectSparseSamples</span>(</span><br><span class="line">    <span class="type">int</span> order, <span class="type">const</span> std::vector&lt;Eigen::Vector3d&gt;&amp; dirs,</span><br><span class="line">    <span class="type">const</span> std::vector&lt;<span class="type">double</span>&gt;&amp; values);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Evaluate the already computed coefficients for the SH basis functions up</span></span><br><span class="line"><span class="comment">// to @order, at the coordinates @phi and @theta. The length of the @coeffs</span></span><br><span class="line"><span class="comment">// vector must be equal to GetCoefficientCount(order).</span></span><br><span class="line"><span class="comment">// There are explicit instantiations for double, float, and Eigen::Array3f.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">EvalSHSum</span><span class="params">(<span class="type">int</span> order, <span class="type">const</span> std::vector&lt;T&gt;&amp; coeffs, <span class="type">double</span> phi, <span class="type">double</span> theta)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// As EvalSHSum, but inputting a direction vector instead of spherical coords.</span></span><br><span class="line"><span class="comment">// Check will fail if @dir is not unit.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">EvalSHSum</span><span class="params">(<span class="type">int</span> order, <span class="type">const</span> std::vector&lt;T&gt;&amp; coeffs, </span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> Eigen::Vector3d&amp; dir)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Render into @diffuse_out the diffuse irradiance for every normal vector</span></span><br><span class="line"><span class="comment">// representable in @diffuse_out, given the luminance stored in @env_map.</span></span><br><span class="line"><span class="comment">// Both @env_map and @diffuse_out use the latitude-longitude projection defined</span></span><br><span class="line"><span class="comment">// specified in ImageX/YToPhi/Theta. They may be of different</span></span><br><span class="line"><span class="comment">// resolutions. The resolution of @diffuse_out must be set before invoking this</span></span><br><span class="line"><span class="comment">// function.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderDiffuseIrradianceMap</span><span class="params">(<span class="type">const</span> Image&amp; env_map, </span></span></span><br><span class="line"><span class="params"><span class="function">                                Image* diffuse_out)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Render into @diffuse_out diffuse irradiance for every normal vector</span></span><br><span class="line"><span class="comment">// representable in @diffuse_out, for the environment represented as the given</span></span><br><span class="line"><span class="comment">// spherical harmonic coefficients, @sh_coeffs. The resolution of</span></span><br><span class="line"><span class="comment">// @diffuse_out must be set before calling this function. Note that a high</span></span><br><span class="line"><span class="comment">// resolution is not necessary (64 x 32 is often quite sufficient).</span></span><br><span class="line"><span class="comment">// See RenderDiffuseIrradiance for how @sh_coeffs is interpreted.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderDiffuseIrradianceMap</span><span class="params">(<span class="type">const</span> std::vector&lt;Eigen::Array3f&gt;&amp; sh_coeffs,</span></span></span><br><span class="line"><span class="params"><span class="function">                                Image* diffuse_out)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compute the diffuse irradiance for @normal given the environment represented</span></span><br><span class="line"><span class="comment">// as the provided spherical harmonic coefficients, @sh_coeffs. Check will</span></span><br><span class="line"><span class="comment">// fail if @normal is not unit length. @sh_coeffs can be of any length. Any</span></span><br><span class="line"><span class="comment">// coefficient provided beyond what&#x27;s used internally to represent the diffuse</span></span><br><span class="line"><span class="comment">// lobe (9) will be ignored. If @sh_coeffs is less than 9, the remaining</span></span><br><span class="line"><span class="comment">// coefficients are assumed to be 0. This naturally means that providing an</span></span><br><span class="line"><span class="comment">// empty coefficient array (e.g. when the environment is assumed to be black and</span></span><br><span class="line"><span class="comment">// not provided in calibration) will evaluate to 0 irradiance.</span></span><br><span class="line"><span class="function">Eigen::Array3f <span class="title">RenderDiffuseIrradiance</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::vector&lt;Eigen::Array3f&gt;&amp; sh_coeffs, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> Eigen::Vector3d&amp; normal)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rotation</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Create a new Rotation that can applies @rotation to sets of coefficients</span></span><br><span class="line">  <span class="comment">// for the given @order. @order must be at least 0.</span></span><br><span class="line">  <span class="function"><span class="type">static</span> std::unique_ptr&lt;Rotation&gt; <span class="title">Create</span><span class="params">(<span class="type">int</span> order,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">const</span> Eigen::Quaterniond&amp; rotation)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a new Rotation that applies the same rotation as @rotation. This</span></span><br><span class="line">  <span class="comment">// can be used to efficiently calculate the matrices for the same 3x3</span></span><br><span class="line">  <span class="comment">// transform when a new order is necessary.</span></span><br><span class="line">  <span class="function"><span class="type">static</span> std::unique_ptr&lt;Rotation&gt; <span class="title">Create</span><span class="params">(<span class="type">int</span> order, <span class="type">const</span> Rotation&amp; rotation)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Transform the SH basis coefficients in @coeff by this rotation and store</span></span><br><span class="line">  <span class="comment">// them into @result. These may be the same vector. The @result vector will</span></span><br><span class="line">  <span class="comment">// be resized if necessary, but @coeffs must have its size equal to</span></span><br><span class="line">  <span class="comment">// GetCoefficientCount(order()).</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// This rotation transformation produces a set of coefficients that are equal</span></span><br><span class="line">  <span class="comment">// to the coefficients found by projecting the original function rotated by</span></span><br><span class="line">  <span class="comment">// the same rotation matrix.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// There are explicit instantiations for double, float, and Array3f.</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Apply</span><span class="params">(<span class="type">const</span> std::vector&lt;T&gt;&amp; coeffs, std::vector&lt;T&gt;* result)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The order (0-based) that the rotation was constructed with. It can only</span></span><br><span class="line">  <span class="comment">// transform coefficient vectors that were fit using the same order.</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">order</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the rotation that is effectively applied to the inputs of the</span></span><br><span class="line">  <span class="comment">// original function.</span></span><br><span class="line">  <span class="function">Eigen::Quaterniond <span class="title">rotation</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the (2l+1)x(2l+1) matrix for transforming the coefficients within</span></span><br><span class="line">  <span class="comment">// band @l by the rotation. @l must be at least 0 and less than or equal to</span></span><br><span class="line">  <span class="comment">// the order this rotation was initially constructed with.</span></span><br><span class="line">  <span class="function"><span class="type">const</span> Eigen::MatrixXd&amp; <span class="title">band_rotation</span><span class="params">(<span class="type">int</span> l)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Rotation</span><span class="params">(<span class="type">int</span> order, <span class="type">const</span> Eigen::Quaterniond&amp; rotation)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> order_;</span><br><span class="line">  <span class="type">const</span> Eigen::Quaterniond rotation_;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;Eigen::MatrixXd&gt; band_rotations_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace sh</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// SH_SPHERICAL_HARMONICS_H_</span></span></span><br></pre></td></tr></table></figure>



                
            </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    


                </div>
            
        </div>
    </div>
</article>

    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    
                        <li>
                            <a href="https://github.com/EauDouceFish" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    

                    
                </ul>
                <p class="copyright text-muted">&copy; 2025 EauDouceFish<br></p>
                <p class="copyright text-muted">Original Theme <a target="_blank" href="http://startbootstrap.com/template-overviews/clean-blog/">Clean Blog</a> from <a href="http://startbootstrap.com/" target="_blank">Start Bootstrap</a></p>
                <p class="copyright text-muted">Adapted for <a target="_blank" href="https://hexo.io/">Hexo</a> by <a href="http://www.codeblocq.com/" target="_blank">Jonathan Klughertz</a></p>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Bootstrap -->
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->



</body>

</html>